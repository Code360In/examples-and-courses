% performance::init, eight_puzzle::initial_state(five_steps, Initial), best_first(25)::solve(eight_puzzle, Initial, Path, Cost), eight_puzzle::print_path(Path), performance::report.


bestfirst(Start, Solution) :-
  expand([], l( Start, 0/0),  9999, _, yes, Solution).

expand(Path, l(State,F/_), _, _, yes, [State|Path], Space, Cost) :-
	goal_state(State).
expand(Path, l(State,F/G), Threshold, Tree, Solved, Solution, Space, Cost) :-
	F =< Threshold,
	(	bagof(Next/Cost2, (next_state(State, Next, Cost2), \+ member_path(Next, Path)), Successors) ->
		succlist(G, Successors, Trees, Threshold, Space),
		bestf(Trees, F2, Threshold),
		expand(Path, t(State, F2/G, Trees), Threshold, Tree, Solved, Solution, Space, Cost)
	;	Solved = never
	).
expand(Path, t(State, F/G,[Tree| Trees]), Threshold, Tree3, Solved, Solution, Space, Cost) :-
	F =< Threshold,
	bestf(Trees, Threshold2, Threshold),
	expand([State|Path], Tree, Threshold2, Tree2, Solved2, Solution, Space, Cost),
	continue(Path, t(State, F/G, [Tree2| Trees]), Threshold, Tree3, Solved2, Solved, Solution, Space, Cost).
expand(_, t(_, _, []), _, _, never, _, _, _) :-
	!.
expand(_, Tree, Threshold, Tree, no, _, _, _) :-
	f(Tree, F),
	F > Threshold.

continue(_, _, _, _, yes, yes, _, _, _).
continue(Path, t(State, _/G, [Tree| Trees]), Threshold, Tree2, no, Solved, Solution, Space, Cost) :-
	insert(Tree, Trees, NewTrees, Threshold),
	bestf(NewTrees, F, Threshold),
	expand(Path, t(State, F/G, NewTrees), Threshold, Tree2, Solved, Solution, Space, Cost).
continue(Path,t(State, _/G, [_| Trees]), Threshold, Tree2, never, Solved, Solution, Space, Cost) :-
	bestf(Trees, F, Threshold),
	expand(Path, t(State, F/G, Trees), Threshold, Tree2, Solved, Solution, Space, Cost).

succlist(_, [], [], _, _).
succlist(G0, [State/Cost| Rest], Trees, Threshold, Space) :-
	G is G0 + Cost,
	heuristic(State, H),
	F is G + H,
	succlist(G0, Rest, Trees2, Threshold, Space),
	insert(l(State, F/G), Trees2, Trees, Threshold).

insert(Tree, [], [Tree], _) :-
	!.
insert(Tree, Trees, [Tree| Trees], Threshold) :-
	f(Tree, F),
	bestf(Trees, F2, Threshold),
	F =< F2,
	!.
insert(Tree, [Tree1| Trees], [Tree1| Trees1], Threshold) :-
	insert(Tree, Trees, Trees1, Threshold).

f(l(_, F/_), F).
f(t(_, F/_, _), F).

bestf([Tree| _], F, _) :-
	f(Tree, F).
bestf([], Threshold, Threshold).




goal_state(goal, [2/2,1/3,2/3,3/3,3/2,3/1,2/1,1/1,1/2]).

print_state([S0,S1,S2,S3,S4,S5,S6,S7,S8]) :-
	member(Y, [3, 2, 1]),
	nl,
	member(X, [1, 2, 3]),
	member( Tile-X/Y, [' '-S0,1-S1,2-S2,3-S3,4-S4,5-S5,6-S6,7-S7,8-S8]),
	write(Tile),
	fail.
print_state(_) :-
	nl.

next_state([Empty| L], [Tile| L2], 1) :-
	swap(Empty, Tile, L, L2).

swap(Empty, Tile, [Tile| L], [Empty| L]) :-
	dist(Empty, Tile, 1).
swap(Empty, Tile, [Tile2| L], [Tile2| L2]) :-
	swap(Empty, Tile, L, L2).

dist(X-Y, X2-Y2, D) :-
	abs_diff(X, X2, Dx),
	abs_diff(Y, Y2, Dy),
	D is Dx + Dy.

abs_diff(A, B, D) :-
	(	A > B ->
		D is A - B
	;	D is B - A
	).

heuristic([_| L], H) :-
	goal_state(_, [_| G]),
	totdist(L, G, 0, D),
	seq(L, S),
	H is D + 3*S.

totdist([], [], D, D).
totdist([T| L], [T2| L2], Acc, D) :-
	dist(T, T2, D1),
	Acc2 is Acc + D1,
	totdist(L, L2, Acc2, D).

seq([First| L], S) :-
	seq([First| L], First, 0, S).

seq([T1, T2| L], First, Acc, S) :-
	score(T1, T2, S1),
	Acc2 is Acc + S1,
	seq([T2| L], First, Acc2, S).
seq([Last], First, Acc, S) :-
	score(Last, First, Score),
	S is Acc + Score.

score(2/2, _, 1) :- !.

score(1/3, 2/3, 0) :- !.
score(2/3, 3/3, 0) :- !.
score(3/3, 3/2, 0) :- !.
score(3/2, 3/1, 0) :- !.
score(3/1, 2/1, 0) :- !.
score(2/1, 1/1, 0) :- !.
score(1/1, 1/2, 0) :- !.
score(1/2, 1/3, 0) :- !.

score(_, _, 2) :- !.
